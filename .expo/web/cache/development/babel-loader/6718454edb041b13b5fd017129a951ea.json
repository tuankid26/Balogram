{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport { crop, flip, resize, rotate } from \"./actions/index.web\";\nimport { getContext } from \"./utils/getContext.web\";\n\nfunction getResults(canvas, options) {\n  var base64;\n\n  if (options) {\n    var _options$compress;\n\n    var _options$format = options.format,\n        format = _options$format === void 0 ? 'png' : _options$format;\n\n    if (options.format === 'png' && options.compress !== undefined) {\n      console.warn('compress is not supported with png format.');\n    }\n\n    var quality = Math.min(1, Math.max(0, (_options$compress = options.compress) != null ? _options$compress : 1));\n    base64 = canvas.toDataURL('image/' + format, quality);\n  } else {\n    base64 = canvas.toDataURL();\n  }\n\n  return {\n    uri: base64,\n    width: canvas.width,\n    height: canvas.height,\n    base64: base64\n  };\n}\n\nfunction loadImageAsync(uri) {\n  return new Promise(function (resolve, reject) {\n    var imageSource = new Image();\n    imageSource.crossOrigin = 'anonymous';\n    var canvas = document.createElement('canvas');\n\n    imageSource.onload = function () {\n      canvas.width = imageSource.naturalWidth;\n      canvas.height = imageSource.naturalHeight;\n      var context = getContext(canvas);\n      context.drawImage(imageSource, 0, 0, imageSource.naturalWidth, imageSource.naturalHeight);\n      resolve(canvas);\n    };\n\n    imageSource.onerror = function () {\n      return reject(canvas);\n    };\n\n    imageSource.src = uri;\n  });\n}\n\nexport default {\n  get name() {\n    return 'ExpoImageManipulator';\n  },\n\n  manipulateAsync: function manipulateAsync(uri) {\n    var actions,\n        options,\n        originalCanvas,\n        resultCanvas,\n        _args = arguments;\n    return _regeneratorRuntime.async(function manipulateAsync$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            actions = _args.length > 1 && _args[1] !== undefined ? _args[1] : [];\n            options = _args.length > 2 ? _args[2] : undefined;\n            _context.next = 4;\n            return _regeneratorRuntime.awrap(loadImageAsync(uri));\n\n          case 4:\n            originalCanvas = _context.sent;\n            resultCanvas = actions.reduce(function (canvas, action) {\n              if ('crop' in action) {\n                return crop(canvas, action.crop);\n              } else if ('resize' in action) {\n                return resize(canvas, action.resize);\n              } else if ('flip' in action) {\n                return flip(canvas, action.flip);\n              } else if ('rotate' in action) {\n                return rotate(canvas, action.rotate);\n              } else {\n                return canvas;\n              }\n            }, originalCanvas);\n            return _context.abrupt(\"return\", getResults(resultCanvas, options));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  }\n};","map":{"version":3,"sources":["../src/ExpoImageManipulator.web.ts"],"names":[],"mappings":"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","sourcesContent":["import { ImageResult, SaveOptions, Action } from './ImageManipulator.types';\nimport { crop, flip, resize, rotate } from './actions/index.web';\nimport { getContext } from './utils/getContext.web';\n\nfunction getResults(canvas: HTMLCanvasElement, options?: SaveOptions): ImageResult {\n  let base64;\n  if (options) {\n    const { format = 'png' } = options;\n    if (options.format === 'png' && options.compress !== undefined) {\n      console.warn('compress is not supported with png format.');\n    }\n    const quality = Math.min(1, Math.max(0, options.compress ?? 1));\n    base64 = canvas.toDataURL('image/' + format, quality);\n  } else {\n    // defaults to PNG with no loss\n    base64 = canvas.toDataURL();\n  }\n  return {\n    uri: base64,\n    width: canvas.width,\n    height: canvas.height,\n    base64,\n  };\n}\n\nfunction loadImageAsync(uri: string): Promise<HTMLCanvasElement> {\n  return new Promise((resolve, reject) => {\n    const imageSource = new Image();\n    imageSource.crossOrigin = 'anonymous';\n    const canvas = document.createElement('canvas');\n    imageSource.onload = () => {\n      canvas.width = imageSource.naturalWidth;\n      canvas.height = imageSource.naturalHeight;\n\n      const context = getContext(canvas);\n      context.drawImage(imageSource, 0, 0, imageSource.naturalWidth, imageSource.naturalHeight);\n\n      resolve(canvas);\n    };\n    imageSource.onerror = () => reject(canvas);\n    imageSource.src = uri;\n  });\n}\n\nexport default {\n  get name(): string {\n    return 'ExpoImageManipulator';\n  },\n  async manipulateAsync(\n    uri: string,\n    actions: Action[] = [],\n    options: SaveOptions\n  ): Promise<ImageResult> {\n    const originalCanvas = await loadImageAsync(uri);\n\n    const resultCanvas = actions.reduce((canvas, action) => {\n      if ('crop' in action) {\n        return crop(canvas, action.crop);\n      } else if ('resize' in action) {\n        return resize(canvas, action.resize);\n      } else if ('flip' in action) {\n        return flip(canvas, action.flip);\n      } else if ('rotate' in action) {\n        return rotate(canvas, action.rotate);\n      } else {\n        return canvas;\n      }\n    }, originalCanvas);\n\n    return getResults(resultCanvas, options);\n  },\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}